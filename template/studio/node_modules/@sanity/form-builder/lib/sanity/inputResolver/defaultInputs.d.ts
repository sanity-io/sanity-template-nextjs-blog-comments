/// <reference types="react" />
import EmailInput from '../../inputs/EmailInput';
import NumberInput from '../../inputs/NumberInput';
import ObjectInput from '../../inputs/ObjectInput';
import StringInput from '../../inputs/StringInput';
import { DateTimeInput, DateInput } from '../../inputs/DateInputs';
import TextInput from '../../inputs/TextInput';
import UrlInput from '../../inputs/UrlInput';
import SanityArrayInput from '../inputs/SanityArrayInput';
import File from '../inputs/SanityFileInput';
declare const _default: {
    object: typeof ObjectInput;
    array: typeof SanityArrayInput;
    boolean: import("react").ForwardRefExoticComponent<import("../../inputs/types").Props<boolean, import("@sanity/types").BooleanSchemaType> & import("react").RefAttributes<HTMLDivElement>>;
    number: typeof NumberInput;
    text: typeof TextInput;
    email: typeof EmailInput;
    datetime: typeof DateTimeInput;
    date: typeof DateInput;
    url: typeof UrlInput;
    image: {
        new (props: any, context: any): {
            _input: any;
            state: {
                document: Record<string, any>;
            };
            unsubscribe: () => void;
            componentWillUnmount(): void;
            focus(): void;
            setInput: (input: any) => void;
            render(): JSX.Element;
            context: any;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<{}>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
            forceUpdate(callback?: () => void): void;
            readonly props: Readonly<{}> & Readonly<{
                children?: import("react").ReactNode;
            }>;
            refs: {
                [key: string]: import("react").ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentDidCatch?(error: Error, errorInfo: import("react").ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
        };
        displayName: string;
        contextTypes: {
            formBuilder: import("prop-types").Requireable<any>;
        };
        contextType?: import("react").Context<any>;
    };
    file: typeof File;
    string: typeof StringInput;
    slug: {
        new <P>(props: P | Readonly<P>): {
            _input: any;
            focus(): void;
            setInput: (input: any) => void;
            render(): JSX.Element;
            context: any;
            setState<K_1 extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<P>) => {} | Pick<{}, K_1>) | Pick<{}, K_1>, callback?: () => void): void;
            forceUpdate(callback?: () => void): void;
            readonly props: Readonly<P> & Readonly<{
                children?: import("react").ReactNode;
            }>;
            state: Readonly<{}>;
            refs: {
                [key: string]: import("react").ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: import("react").ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<{}>, nextContext: any): void;
        };
        new <P>(props: P, context: any): {
            _input: any;
            focus(): void;
            setInput: (input: any) => void;
            render(): JSX.Element;
            context: any;
            setState<K_1 extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<P>) => {} | Pick<{}, K_1>) | Pick<{}, K_1>, callback?: () => void): void;
            forceUpdate(callback?: () => void): void;
            readonly props: Readonly<P> & Readonly<{
                children?: import("react").ReactNode;
            }>;
            state: Readonly<{}>;
            refs: {
                [key: string]: import("react").ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: import("react").ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<{}>, nextContext: any): void;
        };
        displayName: string;
        contextTypes: {
            getValuePath: import("prop-types").Requireable<(...args: any[]) => any>;
            formBuilder: import("prop-types").Requireable<any>;
        };
        contextType?: import("react").Context<any>;
    };
};
export default _default;
