"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createUploadTarget = createUploadTarget;

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _humanizeList = _interopRequireDefault(require("humanize-list"));

var _default = _interopRequireDefault(require("part:@sanity/components/snackbar/default"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _default3 = _interopRequireDefault(require("part:@sanity/components/dialogs/default"));

var _UploadTarget = _interopRequireDefault(require("../../../styles/UploadTarget.css"));

var _extractFiles = require("./extractFiles");

var _imageUrlToBlob = require("./imageUrlToBlob");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// this is a hack for Safari that reads pasted image(s) from an ContentEditable div instead of the onpaste event
function convertImagesToFilesAndClearContentEditable(element) {
  var targetFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'image/jpeg';

  if (!element.isContentEditable) {
    throw new Error("Expected element to be contentEditable=\"true\". Instead found a non contenteditable ".concat(element.tagName));
  }

  return new Promise(resolve => setTimeout(resolve, 10)) // add a delay so the paste event can finish
  .then(() => Array.from(element.querySelectorAll('img'))).then(imageElements => {
    element.innerHTML = ''; // clear

    return imageElements;
  }).then(images => Promise.all(images.map(img => (0, _imageUrlToBlob.imageUrlToBlob)(img.src)))).then(imageBlobs => imageBlobs.map(blob => new File([blob], 'pasted-image.jpg', {
    type: targetFormat
  })));
} // needed by Edge


function select(el) {
  var range = document.createRange();
  range.selectNodeContents(el);
  var sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
}

function createUploadTarget(Component) {
  var _class, _temp;

  return _temp = _class = class UploadTargetFieldset extends _react.default.Component {
    constructor() {
      super(...arguments);

      _defineProperty(this, "_pasteInput", void 0);

      _defineProperty(this, "_element", void 0);

      _defineProperty(this, "dragEnteredEls", []);

      _defineProperty(this, "state", {
        isDraggingOver: false,
        showPasteInput: false,
        rejected: [],
        ambiguous: []
      });

      _defineProperty(this, "handleFocus", event => {
        var onFocus = this.props.onFocus;
        event.stopPropagation();

        if (onFocus) {
          onFocus(['$']);
        }
      });

      _defineProperty(this, "handleKeyPress", event => {
        if (event.target === _reactDom.default.findDOMNode(this) && (event.ctrlKey || event.metaKey) && event.key === 'v') {
          this.setState({
            showPasteInput: true
          });
        }
      });

      _defineProperty(this, "handlePaste", event => {
        (0, _extractFiles.extractPastedFiles)(event.clipboardData).then(files => {
          return files.length > 0 ? files // Invoke Safari hack
          : convertImagesToFilesAndClearContentEditable(this._pasteInput, 'image/jpeg');
        }).then(files => {
          this.uploadFiles(files);
          this.setState({
            showPasteInput: false
          });
        });
      });

      _defineProperty(this, "handleDrop", event => {
        this.setState({
          isDraggingOver: false
        });
        event.preventDefault();
        event.stopPropagation();

        if (this.props.onUpload) {
          (0, _extractFiles.extractDroppedFiles)(event.nativeEvent.dataTransfer).then(files => {
            if (files) {
              this.uploadFiles(files);
            }
          });
        }
      });

      _defineProperty(this, "handleDragOver", event => {
        if (this.props.onUpload) {
          event.preventDefault();
          event.stopPropagation();
        }
      });

      _defineProperty(this, "handleDragEnter", event => {
        event.stopPropagation();
        this.dragEnteredEls.push(event.currentTarget);
        this.setState({
          isDraggingOver: true
        });
      });

      _defineProperty(this, "handleDragLeave", event => {
        event.stopPropagation();
        var idx = this.dragEnteredEls.indexOf(event.currentTarget);

        if (idx > -1) {
          this.dragEnteredEls.splice(idx, 1);
        }

        if (this.dragEnteredEls.length === 0) {
          this.setState({
            isDraggingOver: false
          });
        }
      });

      _defineProperty(this, "setPasteInput", element => {
        // Only care about focus events from children
        this._pasteInput = element;
      });

      _defineProperty(this, "setElement", element => {
        // Only care about focus events from children
        this._element = element;
      });
    }

    uploadFiles(files) {
      var tasks = files.map(file => ({
        file,
        uploaderCandidates: this.props.getUploadOptions(file)
      }));
      var ready = tasks.filter(task => task.uploaderCandidates.length > 0);
      var rejected = tasks.filter(task => task.uploaderCandidates.length === 0);
      this.setState({
        rejected
      }); // todo: consider if we need to ask the user
      // the list of candidates is sorted by their priority and the first one is selected
      // const ambiguous = tasks
      //   .filter(task => task.uploaderCandidates.length > 1)

      ready.forEach(task => {
        this.uploadFile(task.file, (0, _sortBy2.default)(task.uploaderCandidates, candidate => candidate.uploader.priority)[0]);
      });
    }

    uploadFile(file, resolvedUploader) {
      var onUpload = this.props.onUpload;
      var type = resolvedUploader.type,
          uploader = resolvedUploader.uploader;
      onUpload({
        file,
        type,
        uploader
      });
    }

    componentDidUpdate(_, prevState) {
      if (!prevState.showPasteInput && this.state.showPasteInput) {
        this._pasteInput.focus();

        select(this._pasteInput); // Needed by Edge
      } else if (prevState.showPasteInput && !this.state.showPasteInput) {
        this.focus();
      }
    }

    focus() {
      if (this._element) {
        this._element.focus();
      }
    }

    renderSnacks() {
      var _this$state = this.state,
          rejected = _this$state.rejected,
          ambiguous = _this$state.ambiguous;
      var len = ambiguous.length + rejected.length;
      if (len === 0) return null;
      return /*#__PURE__*/_react.default.createElement("div", null, ambiguous.length > 0 &&
      /*#__PURE__*/
      // not in use right now as we just pick the first uploader
      _react.default.createElement(_default3.default, {
        isOpen: true,
        title: "Select how to represent",
        actions: [{
          title: 'Cancel'
        }],
        onAction: () => this.setState({
          ambiguous: []
        })
      }, ambiguous.map(task => /*#__PURE__*/_react.default.createElement("div", {
        key: task.file.name
      }, "The file ", task.file.name, " can be converted to several types of content. Please select how you want to represent it:", /*#__PURE__*/_react.default.createElement("ul", null, task.uploaderCandidates.map(uploaderCandidate => /*#__PURE__*/_react.default.createElement("li", {
        key: uploaderCandidate.type.name
      }, /*#__PURE__*/_react.default.createElement(_default2.default, {
        onClick: () => {
          this.uploadFile(task.file, uploaderCandidate);
          this.setState({
            ambiguous: ambiguous.filter(t => t !== task)
          });
        }
      }, "Represent as ", uploaderCandidate.type.name))))))), rejected.length > 0 && /*#__PURE__*/_react.default.createElement(_default.default, {
        kind: "warning",
        isPersisted: true,
        actionTitle: "OK",
        onAction: () => this.setState({
          rejected: []
        }),
        title: "File(s) not accepted:",
        subtitle: (0, _humanizeList.default)(rejected.map(task => task.file.name))
      }));
    }

    render() {
      var _this$props = this.props,
          children = _this$props.children,
          type = _this$props.type,
          onUpload = _this$props.onUpload,
          getUploadOptions = _this$props.getUploadOptions,
          rest = _objectWithoutProperties(_this$props, ["children", "type", "onUpload", "getUploadOptions"]);

      var _this$state2 = this.state,
          isDraggingOver = _this$state2.isDraggingOver,
          showPasteInput = _this$state2.showPasteInput;
      return /*#__PURE__*/_react.default.createElement(Component, _extends({}, rest, {
        ref: this.setElement,
        onFocus: this.handleFocus,
        onKeyDown: this.handleKeyPress,
        onDragOver: this.handleDragOver,
        onDragEnter: this.handleDragEnter,
        onDragLeave: this.handleDragLeave,
        onDrop: this.handleDrop
      }), isDraggingOver && /*#__PURE__*/_react.default.createElement("div", {
        className: _UploadTarget.default.dragStatus
      }, /*#__PURE__*/_react.default.createElement("h2", {
        className: _UploadTarget.default.dragStatusInner
      }, "Drop to upload")), showPasteInput && /*#__PURE__*/_react.default.createElement("div", {
        className: _UploadTarget.default.dragStatus
      }, /*#__PURE__*/_react.default.createElement("div", {
        contentEditable: true,
        onPaste: this.handlePaste,
        className: _UploadTarget.default.pasteInput,
        ref: this.setPasteInput
      }), /*#__PURE__*/_react.default.createElement("h2", {
        className: _UploadTarget.default.dragStatusInner
      }, "Paste (Ctrl+V or \u2318+V) to upload")), children, this.renderSnacks());
    }

  }, _defineProperty(_class, "defaultProps", {
    tabIndex: 0
  }), _temp;
}