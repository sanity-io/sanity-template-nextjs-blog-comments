"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('lodash'),
    get = _require.get;

var debug = require('../../debug').default;

var getUrlHeaders = require('../../util/getUrlHeaders');

var _require2 = require('../config/reinitializePluginConfigs'),
    tryInitializePluginConfigs = _require2.tryInitializePluginConfigs;

var getSanitySchema = require('./getSanitySchema');

var extractFromSanitySchema = require('./extractFromSanitySchema');

var SchemaError = require('./SchemaError');

var gen1 = require('./gen1');

var gen2 = require('./gen2');

var latestGeneration = 'gen2';
var generations = {
  gen1,
  gen2
};

module.exports = /*#__PURE__*/function () {
  var _deployApiActions = _asyncToGenerator(function* (args, context) {
    var apiClient = context.apiClient,
        workDir = context.workDir,
        output = context.output,
        prompt = context.prompt,
        chalk = context.chalk;
    yield tryInitializePluginConfigs({
      workDir,
      output,
      env: 'production'
    });
    var spinner;
    var flags = args.extOptions;
    var force = flags.force,
        playground = flags.playground;
    var client = apiClient({
      requireUser: true,
      requireProject: true
    });
    var dataset = flags.dataset || client.config().dataset;
    var tag = flags.tag || 'default';
    var generation = flags.generation;

    if (generation && !generations.hasOwnProperty(generation)) {
      throw new Error("Unknown API generation \"".concat(generation, "\""));
    }

    context.output.print("Dataset: ".concat(dataset));
    context.output.print("Tag: ".concat(tag, "\n"));
    spinner = output.spinner('Checking for deployed API').start();
    var currentGeneration = yield getUrlHeaders(client.getUrl("/apis/graphql/".concat(dataset, "/").concat(tag)), {
      Authorization: "Bearer ".concat(client.config().token)
    }).then(res => res['x-sanity-graphql-generation']).catch(err => {
      if (err.statusCode === 404) {
        return null;
      }

      throw err;
    });
    spinner.succeed();
    generation = yield resolveApiGeneration({
      currentGeneration,
      flags,
      output,
      prompt,
      chalk
    });

    if (!generation) {
      // User cancelled
      return;
    }

    var enablePlayground = typeof playground === 'undefined' ? yield prompt.single({
      type: 'confirm',
      message: 'Do you want to enable a GraphQL playground?',
      default: true
    }) : playground;
    spinner = output.spinner('Generating GraphQL schema').start();
    var schema;

    try {
      var generateSchema = generations[generation];
      var sanitySchema = getSanitySchema(workDir);
      var extracted = extractFromSanitySchema(sanitySchema);
      schema = generateSchema(extracted);
    } catch (err) {
      spinner.fail();

      if (err instanceof SchemaError) {
        err.print(output);
        process.exit(1); // eslint-disable-line no-process-exit
      }

      throw err;
    }

    spinner.succeed();
    spinner = output.spinner('Validating GraphQL API').start();
    var valid;

    try {
      valid = yield client.request({
        url: "/apis/graphql/".concat(dataset, "/").concat(tag, "/validate"),
        method: 'POST',
        body: {
          enablePlayground,
          schema
        },
        maxRedirects: 0
      });
    } catch (err) {
      var validationError = get(err, 'response.body.validationError');
      spinner.fail();
      throw validationError ? new Error(validationError) : err;
    }

    if (!(yield confirmValidationResult(valid, {
      spinner,
      output,
      prompt,
      force
    }))) {
      return;
    }

    spinner = output.spinner('Deploying GraphQL API').start();

    try {
      var response = yield client.request({
        url: "/apis/graphql/".concat(dataset, "/").concat(tag),
        method: 'PUT',
        body: {
          enablePlayground,
          schema
        },
        maxRedirects: 0
      });
      spinner.succeed();
      output.print('GraphQL API deployed to:');
      output.print(client.getUrl(response.location.replace(/^\/(v1|v\d{4}-\d{2}-\d{2})\//, '/')));
    } catch (err) {
      spinner.fail();
      throw err;
    }
  });

  function deployApiActions(_x, _x2) {
    return _deployApiActions.apply(this, arguments);
  }

  return deployApiActions;
}();

function confirmValidationResult(_x3, _x4) {
  return _confirmValidationResult.apply(this, arguments);
}

function _confirmValidationResult() {
  _confirmValidationResult = _asyncToGenerator(function* (valid, _ref) {
    var spinner = _ref.spinner,
        output = _ref.output,
        prompt = _ref.prompt,
        force = _ref.force;
    var validationError = valid.validationError,
        breakingChanges = valid.breakingChanges,
        dangerousChanges = valid.dangerousChanges;

    if (validationError) {
      spinner.fail();
      throw new Error("GraphQL schema is not valid:\n\n".concat(validationError));
    }

    var hasProblematicChanges = breakingChanges.length > 0 || dangerousChanges.length > 0;

    if (force && hasProblematicChanges) {
      spinner.text = 'Validating GraphQL API: Dangerous changes. Forced with `--force`.';
      spinner.warn();
      return true;
    } else if (force || !hasProblematicChanges) {
      spinner.succeed();
      return true;
    }

    spinner.warn();

    if (dangerousChanges.length > 0) {
      output.print('\nFound potentially dangerous changes from previous schema:');
      dangerousChanges.forEach(change => output.print(" - ".concat(change.description)));
    }

    if (breakingChanges.length > 0) {
      output.print('\nFound BREAKING changes from previous schema:');
      breakingChanges.forEach(change => output.print(" - ".concat(change.description)));
    }

    output.print('');
    var shouldDeploy = yield prompt.single({
      type: 'confirm',
      message: 'Do you want to deploy a new API despite the dangerous changes?',
      default: false
    });
    return shouldDeploy;
  });
  return _confirmValidationResult.apply(this, arguments);
}

function resolveApiGeneration(_x5) {
  return _resolveApiGeneration.apply(this, arguments);
}

function _resolveApiGeneration() {
  _resolveApiGeneration = _asyncToGenerator(function* (_ref2) {
    var currentGeneration = _ref2.currentGeneration,
        flags = _ref2.flags,
        output = _ref2.output,
        prompt = _ref2.prompt,
        chalk = _ref2.chalk;

    // a) If no API is currently disabled:
    //    use the specificed one, or use whichever generation is the latest
    // b) If an API generation is specified explicitly:
    //    use the given one, but _prompt_ if it differs from the current one
    // c) If no API generation is specified explicitly:
    //    use whichever is already deployed, but warn if differs from latest
    if (!currentGeneration) {
      var _generation = flags.generation || latestGeneration;

      debug('There is no current generation deployed, using %s (%s)', _generation, flags.generation ? 'specified' : 'default');
      return _generation;
    }

    if (flags.generation && flags.generation !== currentGeneration) {
      output.warn("Specified generation (".concat(flags.generation, ") differs from the one currently deployed (").concat(currentGeneration, ")."));
      var confirmDeploy = flags.force || (yield prompt.single({
        type: 'confirm',
        message: 'Are you sure you want to deploy?',
        default: false
      }));
      return confirmDeploy ? flags.generation : null;
    }

    var generation = flags.generation || currentGeneration;

    if (generation !== latestGeneration) {
      output.warn(chalk.cyan("A new generation of the GraphQL API is available, use `--generation ".concat(latestGeneration, "` to use it")));
    }

    if (flags.generation) {
      debug('Using specified (%s) generation', flags.generation);
      return flags.generation;
    }

    debug('Using the currently deployed version (%s)', currentGeneration);
    return currentGeneration;
  });
  return _resolveApiGeneration.apply(this, arguments);
}